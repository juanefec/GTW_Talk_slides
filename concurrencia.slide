Go - Programacion concurrente y patrones comunes

Gracias Rob Pike



* Introduccion

Una de las cosas que mas levanta la atencion del lenguaje es su capacidad nativa para dise√±ar programas concurrentes.

- Que es la programacion concurrente?
- Porque es nativa para go?
- Como lo uso?
- Ejemplos con basicos.
- Ejemplos con patrones concurrentes.





* Que es la programacion concurrencia?

Un programa es concurrente cuando se da la existencia simult√°nea de varios procesos que pueden interactuar.

Por ende es el dise√±o de un programa con multiples procesos que pueden comunicarse.

No es paralelismo. 

La existencia simult√°nea no implica ejecuci√≥n simult√°nea.




* No es paralelismo

No es paralelismo, pero lo permite.

En Go, si tenemos un solo thread del sistema, nuestro programa puede estar escrito de forma concurrente pero no puede ejecutar en paralelo. (magia)

Y ese mismo programa ejecutado con varios threads disponibles podria llegar tener paralelismo.




* Porque la concurrencia es nativa para go?

La concurrencia es un concepto que esta presente en todos lados.

Hasta el hardware que utilizamos hoy en dia utiliza el concepto
 - Procesadores m√∫ltiples
 - Sistemas distribuidos

Simular failmente comportamientos del mundo real.

Y tambien por que es muy dificl simular estructuras de control y tipos primitivos dentro de una libreria. (ej: select{}, chan)

Pero üëÄ
La programaci√≥n concurrente acarrea ciertos problemas, principalmente al momento de compartir informaci√≥n y sincronizar tareas.

Por suerte!
Go nos ayuda a mitigar problemas de sincronizacion y memoria compartida.




* Concurrencia como dise√±o

Facil de entender, usar y pensar.

Sin las herramientas de concurrencia de Go, seria mucho mas complejo replicar un dise√±o concurrente seguro.

Existen mas lenguajes con herramientas de concurrencia nativas:

- Occam (May, 1983)
- Erlang (Armstrong, 1986)
- Newsqueak (Pike, 1988)
- Concurrent ML (Reppy, 1993)
- Alef (Winterbottom, 1995)
- Limbo (Dorward, Pike, Winterbottom, 1996).




* Basic Examples




* Funcion aburrida

Necesitamos un ejemplo para mostrar las propiedades interesantes en los primitivos de concurrencia.

Para evitar distracciones hacemos un ejemplo aburrido.

.play concurrency/support/boring.go /START/,/STOP.*/




* Funcion un poco menos aburrida

Hace los intervalos entre cada print impredecibles (<1000ms)

.play concurrency/support/lessboring.go /START/,/STOP/




* Probamos una rutina

La declaracion go ejecuta la funcion que le sigue, pero no bloquea. (no puede retornar un valor)

Ejecuta una goroutine.

Se podria decir que es como poner al final de un commando de shell un &.

.play concurrency/support/goboring.go 1,/^}/




* Intento fallido

Cuando la funcion main() de un programa finaliza, finalizan las rutinas que estaban ejecutandose.

Esperamos un poco a ver si realmente estan estos dos procesos ejecutandose.

.play concurrency/support/waitgoboring.go /func.main/,/^}/




* Goroutines

Que es una goroutine? Es la ejecucion independiente de una funcion, se usa con el prefijo go delante de la llamada a una funcion.

Tiene su propio call-stack, el mismo se adapta al tama√±o necesario.

Es barato. Es comun ver programas con miles de goroutines, y hasta cientos de miles.

No es un thread.

Un programa con miles de goroutines funciona aunque tenga disponible un solo thread.

Ya que se multiplexan din√°micamente en subprocesos seg√∫n sea necesario para mantener todas las goroutines en ejecuci√≥n.

De todo modos si pensamos en una goroutine como un thread muy barato, no estariamos muy lejos...




* Comunicacion

Nuestros ejemplos aburridos hicieron trampa: nunca se obtuvo desde el main el output de la goroutine

Solo se escribio en la consola...

Para una conversacion es necesatio tener comunicacion




* Channels

Un channel en Go provee una coneccion entre goroutines, permitiendoles comunicarse.

.code concurrency/support/helpers.go /START1/,/STOP1/
.code concurrency/support/helpers.go /START2/,/STOP2/
.code concurrency/support/helpers.go /START3/,/STOP3/




* Usando channels

Un channel que conecta el main y una goroutine aburrida para asi poder comunicarse.

.play concurrency/support/changoboring.go /START1/,/STOP1/
.code concurrency/support/changoboring.go /START2/,/STOP2/




* Sincronizacion

Cuando el main ejecuta <‚Äìc (leer channel) bloquea hasta recibir un nuevo valor.

Tambien cuando la funcion aburrida ejecuta c <‚Äì value (escribir channel) bloquea hasta que se este esperando un valor en c.

El sender y el reciver de la comunicacion necesitan estar listos para hacer su parte, si no, se espera hasta que lo esten.

Por eso es que los channels ademas de comunicar sincronizan.




* !(Buffered channels)

Los channels tambien pueden ser creados con un buffer.

El channel con buffer pierde la sincronizacion

Puede ser importante para resolver determinados tipos de problemas, su uso lleva otro razonamiento.

Hoy no los vamos a ver.




* El approach en Go

"Don't communicate by sharing memory, share memory by communicating."

No comunicarse compartiendo memoria, compartir memoria comunicandote.




* "Patrones"




* Generador: funcion que retorna un channel

El channel es un valor primitivo, como una string o un int.

.play concurrency/support/generatorboring.go /START1/,/STOP1/
.code concurrency/support/generatorboring.go /START2/,/STOP2/




* Channels para manejar servicios

Nuestra funcion aburrida retorna un channel que nos permite comunicarnos con el aburrido servicio que provee.

Esto nos permite crear mas instancias de nuestro servicio aburrido.

.play concurrency/support/generator2boring.go /START1/,/STOP1/




* Multiplexing

El programa anterior deja la cuenta de Ann y Joe en un lockstep, es decir que espera a que los dos hayan hecho su tarea para seguir.

Podemos mejorar eso implementando una funcion fan-in para leer los mensajes de quien sea y redirgirlo al output.

.code concurrency/support/faninboring.go /START3/,/STOP3/
.play concurrency/support/faninboring.go /START1/,/STOP1/




* Fan-in

.image concurrency/images/gophermegaphones.jpg




* Resturar ejecucion.

Desde el proceso podemos mandar un mensaje con un channel.

De esta forma podemos indicarle cuando seguir ejecutandose al proceso.

Entonces, recivo mis mensajes, y despues le indico a cada generador "podes seguir", enviandoles un mensaje al channel que esta en el mensaje recivido.

Parece muy complejo pero no,

Tenemos un generador que retorna un channel para escucharlo, le hacemos fanIn de varios channels a un solo output, y ese output tiene la capacidad de desbloquear la proxima ejecucion del servicio que lo genero.

Definamos un tipo para que el channel del servicio retorne. (este va a tener nuestro channel para indicar la continuacion)

.code concurrency/support/sequenceboring.go /START0/,/STOP0/




* Resturar ejecucion.

Cada generador espera su se√±al para poder seguir con la ejecucion.

.code concurrency/support/sequenceboring.go /START1/,/STOP1/
.code concurrency/support/sequenceboring.go /START2/,/STOP2/
.play concurrency/support/sequenceboring.go /START3/,/STOP3/




* Select

Una estructura de control unicamente para procesos concurrentes.

Dicho por Rob Pike "The reason channels and goroutines are built into the language."

La razon por la cual los channels y las goroutines son parte del lenguaje.




* Select

La declaracion de un select provee otra manera de manejar multiples channels.
Es como un switch, pero cada case es una comunicacion:
- Se evaluan todos los channels.
- Bloquea hasta que haya un channel listo.
- Si se dan multiples cases, se elige de manera pseudo-random.
- Si no hay channels listos, el default se ejecuta instantaneamente.

.code concurrency/support/select.go /START0/,/STOP0/




* Fan-in we go agane

Solo es necesario una goroutine para este tipo de casos.

Old:

.code concurrency/support/faninboring.go /START3/,/STOP3/




* Fan-in select

New:

.play concurrency/support/selectboring.go /START3/,/STOP3/




* Timeout con select

time.After: retorna un channel que bloquea por la duracion especificada.
despues del intervalo envia un time.Time una sola vez.

.play concurrency/support/timeout.go /START1/,/STOP1/




* Timeout de todo el proceso

Creamos el timer UNA SOLA VEZ fuera del loop para finalizar el proceso completo.
(en el programa anterior se hacia timeout de cada mensaje esperado)

.play concurrency/support/timeoutall.go /START1/,/STOP1/





* Exit channel

Podemos cambiar esto y hacer que el generador termine cuando le indequemos.

.code concurrency/support/quit.go /START1/,/STOP1/
.play concurrency/support/quit.go /START2/,/STOP2/





* Notificar el exit.

Como podemos saber si nuestro generador termino con su trabajo?
Esperamos que nos avise: bloqueamos leyendo el channel end luego de enviar la se√±al.

.code concurrency/support/rcvquit.go /START1/,/STOP1/
.play concurrency/support/rcvquit.go /START2/,/STOP2/





* Systems software

Go es un lenguaje dise√±ado para escribir system-software.
Veamos como se pueden utilizar estas features en un sistema.




* Ejemplo: Google Search
	
Q: Que hace el search de google?

A: Dada una query, retorna los resultados de busqueda (y algun ad).

Q: Como obtenemos los resultados de busqueda?

A: Mandamos una peticion al servicio de Webs, Images, Youtube, Maps, News, etc, y combinamos estos resultados. 

Como lo implementamos?




* Google Search: A fake framework

Simulamos una funcion Search.

.code concurrency/support/google.go /START2/,/STOP2/




* Google Search 1.0

La funcion Google toma una query y retorna un slice de resultados

Se ejecuta cada servicio (Web, Video, Image) secuencialmente y se acumulan los resultados.

.code concurrency/support/google.go /START1/,/STOP1/

.play concurrency/support/google.go /func.main/,/}/




* Google Search 2.0

Ahora ejecutamos Web, Image y Video concurrentemente, y esperamos todos los resultados.

Sin locks, sin valiables condicionales, sin callbacks.

.play concurrency/support/google2.1.go /Google/,/^}/




* Google Search 2.1

Somos impacientes...

Asi que agregamos un timeout.

.play concurrency/support/google2.2.go /START/,/STOP/




* Evitar timeouts

Q: Como evito descartar peticiones por timeout?

A: Replicamos el servidor. Enviamos multiples replicas y usamos la primer respuesta. 

.code concurrency/support/google2.3.go /START1/,/STOP1/

.play concurrency/support/google2.3.go /START2/,/STOP2/




* Google Search 3.0

Reducimos el tiempo de respuesta ampliamente, ya que ahora se hacen dos peticiones por servicio y se espera solo a la mas rapida.

.play concurrency/support/google3.0.go /START/,/STOP/




* Sin locks, variables condicionales, ni callbacks.

En unos pocos pasos transformamos un programa lento, secuencial y propenso a fallar en un programa rapido, concurrente, replicado, y robusto.




* No exagerar el uso.

Es un concepto muy divertido de usar, pero no es necesario para todo. Si el problema es simple la solucion tambien.

Las goroutines y los channels son herramientas para la contruccion de software.

Pero aveces lo unico que necesitas es un contador de referencias, para eso esta el pkg "sync" y "sync/atomic", este nos provee de mutexes, variables de condicion, herramientas para problemas mas simples.

Es comun ver a estos dos trabajando juntos para resolver un problemon.

Siempre usemos la herrmienta correcta para el trabajo.




* Conclusions

Las goroutines y los channels facilitan la expresion de operaciones complejas que involucran:

- inputs multiple
- outputs multiple
- timeouts
- errores

Y son divertidos de usar ü§ì
