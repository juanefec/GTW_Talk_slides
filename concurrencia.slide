Go - Programacion concurrente y patrones comunes


Gracias Rob Pike






* Introducci칩n


Una de las cosas que m치s levanta la atenci칩n del lenguaje es su capacidad nativa para dise침ar programas concurrentes.


- Que es la programaci칩n concurrente?
- Porque es nativa para go?
- Como lo uso?
- Ejemplos con b치sicos.
- Ejemplos con patrones concurrentes.










* Que es la programaci칩n concurrente?


Un programa es concurrente cuando se da la existencia simult치nea de varios procesos que pueden interactuar.


Por ende es el dise침o de un programa con m칰ltiples procesos que pueden comunicarse.


No es paralelismo. 


La existencia simult치nea no implica ejecuci칩n simult치nea.








* No es paralelismo


No es paralelismo, pero lo permite.


En Go, si tenemos un solo thread del sistema, nuestro programa puede estar escrito de forma concurrente pero no puede ejecutar en paralelo. (magia)


Y ese mismo programa ejecutado con varios threads disponibles podr칤a llegar tener paralelismo.








* Porque la concurrencia es nativa para go?


La concurrencia es un concepto que esta presente en todos lados.


Hasta el hardware que utilizamos hoy en d칤a utiliza el concepto
 - Procesadores m칰ltiples
 - Sistemas distribuidos


Simular f치cilmente comportamientos del mundo real.


Y tambi칠n por que es muy dif칤cil simular estructuras de control y tipos primitivos dentro de una librer칤a. (ej: select{}, chan)


Pero 游
La programaci칩n concurrente acarrea ciertos problemas, principalmente al momento de compartir informaci칩n y sincronizar tareas.


Por suerte! 游뱔
Go nos ayuda a mitigar problemas de sincronizaci칩n y memoria compartida.








* Concurrencia como dise침o


F치cil de entender, usar y pensar.


Sin las herramientas de concurrencia de Go, seria mucho m치s complejo replicar un dise침o concurrente seguro.


Existen m치s lenguajes con herramientas de concurrencia:
- Occam (May, 1983)
- Erlang (Armstrong, 1986)
- Newsqueak (Pike, 1988)
- Concurrent ML (Reppy, 1993)
- Alef (Winterbottom, 1995)
- Limbo (Dorward, Pike, Winterbottom, 1996).








* Basic Examples








* Funci칩n aburrida


Necesitamos un ejemplo para mostrar las propiedades interesantes en los primitivos de concurrencia.


Para evitar distracciones hacemos un ejemplo aburrido.


.play concurrency/support/boring.go /START/,/STOP.*/








* Funci칩n un poco menos aburrida

Hace los intervalos entre cada print impredecibles (<1000ms)

.play concurrency/support/lessboring.go /START/,/STOP/




* Probamos una rutina

La declaraci칩n go ejecuta la funci칩n que le sigue, pero no bloquea. (no puede retornar un valor)

Ejecuta una goroutine.

Se podr칤a decir que es como poner al final de un comando de shell un &.

.play concurrency/support/goboring.go 1,/^}/




* Intento fallido

Cuando la funci칩n main() de un programa finaliza, finalizan las rutinas que estaban ejecut치ndose.

Esperamos un poco a ver si realmente est치n estos dos procesos ejecut치ndose.

.play concurrency/support/waitgoboring.go /func.main/,/^}/




* Goroutines

Que es una goroutine? Es la ejecuci칩n independiente de una funci칩n, se usa con el prefijo go delante de la llamada a una funci칩n.

Tiene su propio call-stack, el mismo se adapta al tama침o necesario.

Es barato. Es com칰n ver programas con miles de goroutines, y hasta cientos de miles.

No es un thread.

Un programa con miles de goroutines funciona aunque tenga disponible un solo thread.

Ya que se multiplexan din치micamente en subprocesos seg칰n sea necesario para mantener todas las goroutines en ejecuci칩n.

De todos modos si pensamos en una goroutine como un thread muy barato, no estar칤amos muy lejos...




* Comunicaci칩n

Nuestros ejemplos aburridos hicieron trampa: nunca se obtuvo desde el main el output de la goroutine

칔nicamente se escribi칩 en la consola...

Para una conversaci칩n es necesario tener comunicaci칩n




* Channels

Un channel en Go provee una conexi칩n entre goroutines, permiti칠ndoles comunicarse.

.code concurrency/support/helpers.go /START1/,/STOP1/
.code concurrency/support/helpers.go /START2/,/STOP2/
.code concurrency/support/helpers.go /START3/,/STOP3/




* Usando channels

Un channel que conecta el main y una goroutine aburrida para as칤 poder comunicarse.

.play concurrency/support/changoboring.go /START1/,/STOP1/
.code concurrency/support/changoboring.go /START2/,/STOP2/




* Sincronizaci칩n

Cuando el main ejecuta 
.code concurrency/support/helpers.go /START3/,/STOP3/
bloquea hasta recibir un nuevo valor.

Tambi칠n cuando la funci칩n aburrida ejecuta 
.code concurrency/support/helpers.go /START2/,/STOP2/
bloquea hasta que se est칠 esperando un valor en c.

El sender y el reciver de la comunicaci칩n necesitan estar listos para hacer su parte, si no, se espera hasta que lo est칠n.

Por eso es que los channels adem치s de comunicar sincronizan.




* !(Buffered channels)

Los channels tambi칠n pueden ser creados con un buffer.

El channel con buffer pierde la sincronizaci칩n

Puede ser importante para resolver determinados tipos de problemas, su uso lleva otro razonamiento.

Hoy no los vamos a ver.




* El approach en Go

"Don't communicate by sharing memory, share memory by communicating."

No comunicar compartiendo memoria, compartir memoria comunicando.




* "Patrones"




* Generador: funci칩n que retorna un channel

El channel es un valor primitivo, como una string o un int.

.play concurrency/support/generatorboring.go /START1/,/STOP1/
.code concurrency/support/generatorboring.go /START2/,/STOP2/




* Channels para manejar servicios

Nuestra funci칩n aburrida retorna un channel que nos permite comunicarnos con el aburrido servicio que provee.

Esto nos permite crear m치s instancias de nuestro servicio aburrido.

.play concurrency/support/generator2boring.go /START1/,/STOP1/




* Multiplexing

El programa anterior deja la cuenta de Ann y Joe en un lockstep, es decir que espera a que los dos hayan hecho su tarea para seguir.

Podemos mejorar eso implementando una funci칩n fan-in para leer los mensajes de quien sea y redirigirlo al output.

.code concurrency/support/faninboring.go /START3/,/STOP3/
.play concurrency/support/faninboring.go /START1/,/STOP1/




* Fan-in

.image concurrency/images/gophermegaphones.jpg




* Restaurar ejecuci칩n.

Desde el proceso podemos mandar un mensaje con un channel.

De esta forma podemos indicarle cuando seguir ejecut치ndose al proceso.

Entonces, recibo mis mensajes, y despu칠s le indico a cada generador "pod칠s seguir", envi치ndoles un mensaje al channel que est치 en el mensaje recibido.

Parece muy complejo pero no,

Tenemos un generador que retorna un channel para escucharlo, le hacemos fanIn de varios channels a un solo output, y ese output tiene la capacidad de desbloquear la pr칩xima ejecuci칩n del servicio que lo genero.

Definamos un tipo para que el channel del servicio retorne. (este va a tener nuestro channel para indicar la continuaci칩n)

.code concurrency/support/sequenceboring.go /START0/,/STOP0/




* Restaurar ejecuci칩n.

Cada generador espera su se침al para poder seguir con la ejecuci칩n.

.code concurrency/support/sequenceboring.go /START1/,/STOP1/
.code concurrency/support/sequenceboring.go /START2/,/STOP2/
.play concurrency/support/sequenceboring.go /START3/,/STOP3/




* Select

Una estructura de control 칰nicamente para procesos concurrentes.

Dicho por Rob Pike "The reason channels and goroutines are built into the language."

La raz칩n por la cual los channels y las goroutines son parte del lenguaje.




* Select

La declaraci칩n de un select provee otra manera de manejar m칰ltiples channels.
Es como un switch, pero cada case es una comunicaci칩n:
- Se eval칰an todos los channels.
- Bloquea hasta que haya un channel listo.
- Si se dan m칰ltiples cases, se elige de manera pseudo-random.
- Si no hay channels listos, el default se ejecuta instant치neamente.

.code concurrency/support/select.go /START0/,/STOP0/




* Fan-in we go agane

Solo es necesario una goroutine para este tipo de casos.

Old:

.code concurrency/support/faninboring.go /START3/,/STOP3/




* Fan-in select

New:

.play concurrency/support/selectboring.go /START3/,/STOP3/




* Timeout con select

time.After: retorna un channel que bloquea por la duraci칩n especificada.
despu칠s del intervalo env칤a un time.Time una sola vez.

.play concurrency/support/timeout.go /START1/,/STOP1/




* Timeout de todo el proceso

Creamos el timer UNA SOLA VEZ fuera del loop para finalizar el proceso completo.
(en el programa anterior se hac칤a timeout de cada mensaje esperado)

.play concurrency/support/timeoutall.go /START1/,/STOP1/





* Exit channel

Podemos cambiar esto y hacer que el generador termine cuando le indiquemos.

.code concurrency/support/quit.go /START1/,/STOP1/
.play concurrency/support/quit.go /START2/,/STOP2/





* Notificar el exit.

Como podemos saber si nuestro generador termino con su trabajo?
Esperamos que nos avise: bloqueamos leyendo el channel end luego de enviar la se침al.

.code concurrency/support/rcvquit.go /START1/,/STOP1/
.play concurrency/support/rcvquit.go /START2/,/STOP2/





* Systems software

Go es un lenguaje dise침ado para escribir system-software.
Veamos como se pueden utilizar estas features en un sistema.




* Ejemplo: Google Search
	
Q: Que hace el search de google?

A: Dada una query, retorna los resultados de b칰squeda (y alg칰n ad).

Q: Como obtenemos los resultados de b칰squeda?

A: Mandamos una petici칩n al servicio de Webs, Images, Youtube, Maps, News, etc., y combinamos estos resultados. 

Como lo implementamos?




* Google Search: A fake framework

Simulamos una funci칩n Search.

.code concurrency/support/google.go /START2/,/STOP2/




* Google Search 1.0

La funci칩n Google toma una query y retorna un slice de resultados

Se ejecuta cada servicio (Web, Video, Image) secuencialmente y se acumulan los resultados.

.code concurrency/support/google.go /START1/,/STOP1/

.play concurrency/support/google.go /func.main/,/}/




* Google Search 2.0

Ahora ejecutamos Web, Image y Video concurrentemente, y esperamos todos los resultados.

Sin locks, sin variables condicionales, sin callbacks.

.play concurrency/support/google2.1.go /Google/,/^}/




* Google Search 2.1

Somos impacientes...

As칤 que agregamos un timeout.

.play concurrency/support/google2.2.go /START/,/STOP/




* Evitar timeouts

Q: Como evito descartar peticiones por timeout?

A: Replicamos el servidor. Enviamos m칰ltiples r칠plicas y usamos la primera respuesta. 

.code concurrency/support/google2.3.go /START1/,/STOP1/

.play concurrency/support/google2.3.go /START2/,/STOP2/




* Google Search 3.0

Reducimos el tiempo de respuesta ampliamente, ya que ahora se hacen dos peticiones por servicio y se espera solo a la m치s r치pida.

.play concurrency/support/google3.0.go /START/,/STOP/




* Sin locks, variables condicionales, ni callbacks.

En unos pocos pasos transformamos un programa lento, secuencial y propenso a fallar en un programa r치pido, concurrente, replicado, y robusto.




* No exagerar el uso.

Es un concepto muy divertido de utilizar, pero no es necesario para todo. Si el problema es simple la soluci칩n tambi칠n.

Las goroutines y los channels son herramientas para la construcci칩n de software.

Pero a veces lo 칰nico que necesitas es un contador de referencias, para eso est치 el pkg "sync" y "sync/atomic", este nos provee de mutexes, variables de condici칩n, herramientas para problemas m치s simples.

Es com칰n ver a estos dos trabajando juntos para resolver un problemon.

Siempre usemos la herramienta correcta para el trabajo.




* Conclusi칩n

Las goroutines y los channels facilitan la expresi칩n de operaciones complejas que involucran:

- inputs m칰ltiples
- outputs m칰ltiples
- timeouts
- errores

Y son divertidos de usar 游뱁
